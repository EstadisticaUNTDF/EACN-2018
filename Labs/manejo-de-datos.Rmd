# Manejo de datos

Una parte muy importante del análisis de datos, es el manejo de ellos. Como
seleccionar columnas, filtrar datos, y realizar operaciones sobre ellos. Vamos
a usar el paquete `dplyr` y `tidyr` para el manejo. Los paquetes 
extienden la funcionalidad de *R* agregando nuevas funciones.

```{r cargar-datos, eval=final_knit}
library("dplyr")

nombres <- readRDS("data/nombres-1980-1999.RDS")

```

Revisemos el código. Con `library("dplyr")` cargamos el paquete dplyr. Luego,
leemos el archivo que contiene los datos y le asignamos el nombre `nombres`.
Si no le asignasemos ningún nombre, se leerían los datos, imprimiendose en la
consola y luego se borrarían de la memoría. 

Para revisar su contenido podemos escribir el nombre del objeto o usar la 
función `glimpse`

```{r ver-datos, eval=FALSE}
glimpse(nombres)
```

```{exercise ejercicio-4}
Escriban el nombre del objeto o usen la función `glimpse` para ver que tiene
dentro el objeto `nombres`.

1. ¿Cuantas columnas tiene y como se llaman?
2. ¿Que tipo de dato tiene cada columna?
```

En *R* existen diversos tipos de dato, en estos datos solo hay 2: entero 
(`integer`) y carácter (`character`). El primero son números enteros y el 
segundo es texto. Con el primero se puede hacer operaciones matemáticas y con
el segundo otro tipo de operaciones, pero no matemáticas. Es importante 
comprobar que los tipos de datos se correspondan con lo que esperamos. Si no
los resultados pueden no ser los correctos o dar errores. Por ejemplo, el
tipo de dato númerico puede ser leído como `chr` y no podremos calcular la 
media.

## Seleccionando datos

Muchas veces solo nos interesa un subconjunto de datos. Una forma de seleccionar
datos es usando la función `filter()`. 

```{r filtrar-luciano, eval=FALSE}
nombres %>% 
  filter(nombre == "Luciano") %>% 
  filter(anio == 1984)
```

Acá empezamos a ver varias cosas nuevas. Primero tenemos el símbolo `%>%` 
conocido en inglés como *pipe*, la traducción más correcta al español es 
tubo. Lo que hace este símbolo es enviar la salida de la operación a la 
izquierda a la función de la derecha. Prueben poner cada comando en orden
y ver cual es la salida. Esto es:

```{r paso-1, eval=FALSE}
nombres
```

Luego,

```{r paso-2, eval=FALSE}
nombres %>% 
  filter(nombre == "Luciano")
```

La función `filter()` filtra un conjunto de datos según los valores de la
columna/s que seleccionemos cuyos valores sean igual a `Luciano` en este caso. Y
luego filtramos la columna `anio` solo los años que sean iguales a 1984.


```{exercise ejercicio-5}
Prueben cambiar el nombre por el suyo y el año por su año de nacimiento. 
```

El operador que usamos para la igualdad es `==`. Este operador, de igualdad,
es parte de la familia de operadores lógicos, o booleanos en terminología
de ciencias de la información. Son lógicos porque van a comparar valores y
dar como resultado **verdadero** (`TRUE`) o **falso** (`FALSE`). En la Tabla
\@ref(tab:tabla-logicos) podemos ver la lista de operadores lógicos.

```{r tabla-logicos, message=FALSE, echo=FALSE}
readr::read_csv2(file = "tablas/logicos.txt") %>% 
  knitr::kable(caption = "Operadores Lógicos en R.")
```

Los primeros cinco son bastante sencillos y los han estado usando desde la 
primaria. Así que vamos a explicar en más profundidad los otros. El símbolo `!=`
va a devolver `TRUE` cuando los valores sean diferentes al que pusimos. Por 
ejemplo:

```{r distinto}
# x una secuencia de 1 a 10
x <- 1:10
# Todos los valores distintos a 5
x != 5
```

Otro operador muy útil es el de negación `!` que invierte las comparaciones,
convierte los falsos en verdaderos y los verdaderos en falsos. Siguiendo nuestro
ejemplo:

```{r negacion}
!x != 5
```

Es un ejemplo trivial, que podría haber sido resuelto más sencillamente usando
`==`. Pero es muy útil cuando queremos seleccionar todos los datos que no cumplan
un conjuto de condiciones. Lo que nos lleva al operador `|` (*O*) y el operador
`&` (*Y*). El primero va a devolver verdadero cuando *al menos uno* de los
valores sea verdadero. Por ejemplo:

```{r o-logico}
TRUE | TRUE
TRUE | FALSE
FALSE | TRUE
FALSE | FALSE
```

Por otro lado, el operador lógico *Y* `&` solo devuelve verdadero cuando *ambos
valores* son verdaderos.

```{r y-logico}
TRUE & TRUE
TRUE & FALSE
FALSE & TRUE
FALSE & FALSE
```

Los operadores se evalúan en el orden que aparecen a menos que haya paréntesis,
entonces se evalúa primero dentro del paréntesis y luego fuera.


```{exercise ejercicio-6}
¿Qué resultado darán las siguientes evaluaciones? Piensen que resultado tendría
que dar y luego comprueben lo que piensan con lo que les devuelve R.

  1. TRUE | FALSE | TRUE
  2. TRUE | FALSE & TRUE
  3. TRUE | (FALSE & TRUE)
  4. TRUE != FALSE & TRUE
  5. !(TRUE | FALSE) & TRUE
  
```

Estos dos últimos operadores son muy importantes porque nos permiten comprobar
distintas condiciones. Por ejemplo, no hay un operador para seleccionar todos
los valores entre *a* y *b* (siendo *a* y *b* dos números cualesquiera). Podemos
hacerlo combinando por un lado, x > a y x < b ¿Y cómo debemos combinar estas 
dos comparaciones? ¿Usando el operador `&` o el `|`? Queremos los valores que
cumplen con ambas condiciones, que sean mayores que a y menores que b, por lo 
tanto debemos usar el operador `&`.

```{r combinar-logicos}
# Si a = 3 y b = 6
( x > 3 ) & ( x < 6)
```

Estos valores corresponden a la posición de los valores que cumplen o no con la 
condición. Usando corchetes `[]` podemos seleccionar solo los verdaderos

```{r extraer-valores-logicos}
x[( x > 3 ) & ( x < 6)]
```

La función `filter()` hace algo similar para conjuntos de datos (`data.frames` o
`tibbles`).

```{exercise ejercicio-7}
Anteriormente usamos dos operaciones de `filter()` para seleccionar el nombre y
el año. Pero es posible usar solo una con los operadores lógicos que vimos. 
Intenten hacerlo.
```

Finalmente está `isTRUE()` que devuelve `TRUE` cuando el objeto es `TRUE`
lo que suena bastante obvio. Pero es parte de una familia que permite comprobar
si un objeto es del tipo esperado. Por ejempo: `is.numeric()` comprueba que el 
objeto es un vector con algún tipo de número. 

Otra forma de seleccionar datos es por posición. Es decir, seleccionar los 
primeras diez filas:

```{r primeros-10}
nombres %>% 
  slice(1:10)

```

O seleccionar las primeras 10 filas que corresponden números primos:

```{r primos}
nombres %>% 
  slice(c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29))
```

También es posible eliminar las filas según posición:

```{r}
nombres %>% 
  slice(-(1:10)) #Tengan en cuenta los parentesis extra
```

```{exercise ejercicio-8}

1. ¿Qué sucede si olvidan los paréntesis en el código de arriba?
2. Seleccionen las últimas 10 filas.
```

## Agregando columnas

Otra operación muy común es agregar nuevas columnas o variables. Por ejemplo
al transformar los datos es siempre **mala idea** sobreescribir los datos 
originales.

Para esta operación sirve la función `mutate()`. Dado un *data frame* computa
una valor para cada fila. Por ejemplo:

```{r}
nombres %>% 
  mutate(log_cantidad = log10(cantidad) )
```




## Operaciones por grupos

Muchas veces van a necesitar calcular por grupos: la suma, media, varianza, etc.
Por ejemplo, calcular el número total de personas con cada nombre. Podrían 
hacerlo de esta forma:

```{r filtrado, eval=final_knit}
nombres %>% 
  filter(nombre == "Luciano") %>% 
  summarise(total = sum(cantidad))
```

Y repetirlo cambiando el nombre para cada uno de los nombres. Por su puesto,
esta forma de hacer las cosas es muy incómoda y propensa a errores. Hay una
forma más fácil y es usando `group_by()`. Un ejemplo:

```{r agrupado, eval=final_knit}
# No intenten hacerlo en sus computadoras
# Los datos tienen más de 3 millones de registros y va a tomar un tiempo
nombres %>% 
  group_by(nombre) %>% 
  summarise(total = sum(cantidad))
```

Como pueden ver estos datos distan bastante de estar limpios ya que hay 
muchos errores de entrada de datos, como nombres todo en mayúsculas, versiones
del mismo nombre con tilde y sin tilde, etc. Para evitar todo ese "ruido", 
podríamos filtrar los nombres raros que son mayoría de las entradas.

```{exercise ejercicio-8, label="nombre-comun", name="Nombres comunes"}
¿Cómo filtrarían los nombres raros excluyéndolos del conjunto de datos? 
  
  Guarden el resultado como nombres_comunes y calculen el total por nombre.

Nota: Por coherencia, definamos nombres raros como los que son menos de 100.
```


```{r solucion-suma-nombres, echo=solucion, eval=final_knit}
nombres_comunes <- nombres %>% 
  filter(cantidad > 100)
nombres_comunes %>% 
  group_by(nombre) %>% 
  summarise(total = sum(cantidad))
```

Por defecto esta ordenado alfabeticamente por nombre. Podemos ordenarlo según
algún otro criterio con la función `arrange()`. Esta función ordena de manera
creciente (0-9, a-z) un conjunto de datos. Por ejemplo:

```{r orden, eval=final_knit}
nombres_comunes %>% 
  arrange(cantidad)
```

Si queremos que sea decreciente (9-0, z-a), hay que agregar la función `desc()`.
Por ejemplo:

```{r orden-decreciente, eval=final_knit}
nombres_comunes %>% 
  arrange(desc(cantidad))
```

También se pueden poner varios criterios para que ordene según ellos. Por 
ejemplo, por cantidad y luego por orden alfabético. 

```{r orden-con-dos, eval=final_knit}
nombres_comunes %>% 
  arrange(cantidad, nombre)
```

```{exercise ejercicio-9, name="Orden de totales"}
Ordenen el resultado del total de nombres que calcularon en el ejercicio 
\@ref(exr:nombre-comun)
```



# Por su cuenta

Lean los datos de 

```{r eval=FALSE}
load("inventario.RData")
```

Son datos del inventario de plantaciones forestales. Están dividades en plantaciones
de cortina y de macizo. La unidad de medida son metros cúbicos de madera.

1. ¿Qué columnas hay y cuantos datos encuentran?
2. Calculen una nueva columna `total`con el total de metros cúbicos. 
Pista: pueden usar la función `mutate` que funciona de manera similar a `summarise`
3. Calculen el promedio y la suma total de metros cúbicos por provincia.
4. Ordenen las provincias por el totla de metros cúbicos. 
5. Grafiquen cada uno de los datos de cada provincia, distiguiendo si se trata
de metros cúbicos de cortina o de macizo. 
6. Seleccionen los datos de la provincia de Neuquén.
7. Grafiquen los datos de cada departamento de Neuquén
